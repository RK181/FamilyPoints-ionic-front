/* tslint:disable */
/* eslint-disable */
/**
 * FamilyPoints - OpenAPI 3.0
 * Documentacion de la aplicaion FamilyPoints. Una aplicación para gestionar el intercambio de favores entre miembros de la misma familia (quedarse una noche con los niños, cocinar para toda la semana, etc.), qué se acumularán como puntos canjeables por actividades lúdicas (noche libre con amigos, spa, tarde de videojuegos, etc.).    `Trabajo Final de Grado, Universidad de Alicante 2023-24.`   `Autor: Robert Kazaryan.`
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'points_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'points_icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupRequest
     */
    'conf_t_approve': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupRequest
     */
    'conf_t_validate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupRequest
     */
    'conf_t_invalidate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupRequest
     */
    'conf_r_valiadte': boolean;
    /**
     * 
     * @type {GroupCreator}
     * @memberof CreateGroupRequest
     */
    'creator'?: GroupCreator;
    /**
     * 
     * @type {GroupCouple}
     * @memberof CreateGroupRequest
     */
    'couple'?: GroupCouple;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'points_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'points_icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'conf_t_approve'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'conf_t_validate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'conf_t_invalidate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'conf_r_valiadte'?: boolean;
    /**
     * 
     * @type {GroupCreator}
     * @memberof Group
     */
    'creator'?: GroupCreator;
    /**
     * 
     * @type {GroupCouple}
     * @memberof Group
     */
    'couple'?: GroupCouple;
}
/**
 * 
 * @export
 * @interface GroupCouple
 */
export interface GroupCouple {
    /**
     * 
     * @type {string}
     * @memberof GroupCouple
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupCouple
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupCouple
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupCouple
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface GroupCreator
 */
export interface GroupCreator {
    /**
     * 
     * @type {string}
     * @memberof GroupCreator
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupCreator
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupCreator
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupCreator
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface LoginUserRequest
 */
export interface LoginUserRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserRequest
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof LoginUserRequest
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    'cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'expire_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Reward
     */
    'redeem'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Reward
     */
    'validate'?: boolean;
    /**
     * 
     * @type {RewardUser}
     * @memberof Reward
     */
    'user'?: RewardUser;
}
/**
 * 
 * @export
 * @interface RewardUser
 */
export interface RewardUser {
    /**
     * 
     * @type {string}
     * @memberof RewardUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardUser
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewardUser
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface SignupUserRequest
 */
export interface SignupUserRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupUserRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignupUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignupUserRequest
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof SignupUserRequest
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'reward'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'expire_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'approve'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'complete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'validate'?: boolean;
    /**
     * 
     * @type {TaskCreator}
     * @memberof Task
     */
    'creator'?: TaskCreator;
    /**
     * 
     * @type {TaskUser}
     * @memberof Task
     */
    'user'?: TaskUser;
}
/**
 * 
 * @export
 * @interface TaskCreator
 */
export interface TaskCreator {
    /**
     * 
     * @type {string}
     * @memberof TaskCreator
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCreator
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCreator
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskCreator
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface TaskUser
 */
export interface TaskUser {
    /**
     * 
     * @type {string}
     * @memberof TaskUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskUser
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskUser
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'points'?: number;
}
/**
 * 
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ValidationErrorResponseErrors}
     * @memberof ValidationErrorResponse
     */
    'errors'?: ValidationErrorResponseErrors;
}
/**
 * 
 * @export
 * @interface ValidationErrorResponseErrors
 */
export interface ValidationErrorResponseErrors {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'email'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'password'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'points_name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'points_icon'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'title'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorResponseErrors
     */
    'description'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ValidationErrorResponseErrors
     */
    'cost'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ValidationErrorResponseErrors
     */
    'reward'?: Array<number>;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Un usuario registrado inicia la sesion. El usuario debe de haber verificado su email.
         * @summary Iniciar sesion
         * @param {LoginUserRequest} [loginUserRequest] Cuerpo de peticion para iniciar la sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginUserRequest?: LoginUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cierra todas las sesiones del usuario
         * @summary Terminar sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un usuario en el sistema y envia un correo electronico de confirmacion al email proporcionado. Para registrar al usuario definitivamente es imprescindible confirmar el correo electronico.
         * @summary Registrar un usuario
         * @param {SignupUserRequest} [signupUserRequest] Cuerpo de peticion para registrar nuevo usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser: async (signupUserRequest?: SignupUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Un usuario registrado inicia la sesion. El usuario debe de haber verificado su email.
         * @summary Iniciar sesion
         * @param {LoginUserRequest} [loginUserRequest] Cuerpo de peticion para iniciar la sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginUserRequest?: LoginUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.loginUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Cierra todas las sesiones del usuario
         * @summary Terminar sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.logoutUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Crea un usuario en el sistema y envia un correo electronico de confirmacion al email proporcionado. Para registrar al usuario definitivamente es imprescindible confirmar el correo electronico.
         * @summary Registrar un usuario
         * @param {SignupUserRequest} [signupUserRequest] Cuerpo de peticion para registrar nuevo usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupUser(signupUserRequest?: SignupUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupUser(signupUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.signupUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Un usuario registrado inicia la sesion. El usuario debe de haber verificado su email.
         * @summary Iniciar sesion
         * @param {LoginUserRequest} [loginUserRequest] Cuerpo de peticion para iniciar la sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginUserRequest?: LoginUserRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.loginUser(loginUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cierra todas las sesiones del usuario
         * @summary Terminar sesion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un usuario en el sistema y envia un correo electronico de confirmacion al email proporcionado. Para registrar al usuario definitivamente es imprescindible confirmar el correo electronico.
         * @summary Registrar un usuario
         * @param {SignupUserRequest} [signupUserRequest] Cuerpo de peticion para registrar nuevo usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(signupUserRequest?: SignupUserRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.signupUser(signupUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Un usuario registrado inicia la sesion. El usuario debe de haber verificado su email.
     * @summary Iniciar sesion
     * @param {LoginUserRequest} [loginUserRequest] Cuerpo de peticion para iniciar la sesion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginUser(loginUserRequest?: LoginUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginUser(loginUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cierra todas las sesiones del usuario
     * @summary Terminar sesion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un usuario en el sistema y envia un correo electronico de confirmacion al email proporcionado. Para registrar al usuario definitivamente es imprescindible confirmar el correo electronico.
     * @summary Registrar un usuario
     * @param {SignupUserRequest} [signupUserRequest] Cuerpo de peticion para registrar nuevo usuario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signupUser(signupUserRequest?: SignupUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signupUser(signupUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea un grupo de dos usuarios. Cada usuario solo puede pertenecer a un grupo
         * @summary Crear el grupo
         * @param {CreateGroupRequest} [createGroupRequest] Cuerpo de peticion para crear nuevo grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupRequest?: CreateGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Borra el grupo mediante el token de sesion JWT del usuario
         * @summary Borrar el grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se obtiene informacion del grupo mediante el token de sesion del JWT del usuario
         * @summary Obtener los datos del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se manda un correo electronico con la invitacion para unirse al grupo
         * @summary Invitar a la pareja al grupo
         * @param {string} email Correo electronico del usuario a invitar al grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteToGroup: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('inviteToGroup', 'email', email)
            const localVarPath = `/group/invitation/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifica los datos del grupo, los campos a modificar se elegen de manera opcional
         * @summary Modificar los datos del grupo
         * @param {Group} [group] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (group?: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea un grupo de dos usuarios. Cada usuario solo puede pertenecer a un grupo
         * @summary Crear el grupo
         * @param {CreateGroupRequest} [createGroupRequest] Cuerpo de peticion para crear nuevo grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupRequest?: CreateGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.createGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Borra el grupo mediante el token de sesion JWT del usuario
         * @summary Borrar el grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.deleteGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Se obtiene informacion del grupo mediante el token de sesion del JWT del usuario
         * @summary Obtener los datos del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.getGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Se manda un correo electronico con la invitacion para unirse al grupo
         * @summary Invitar a la pareja al grupo
         * @param {string} email Correo electronico del usuario a invitar al grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteToGroup(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteToGroup(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.inviteToGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modifica los datos del grupo, los campos a modificar se elegen de manera opcional
         * @summary Modificar los datos del grupo
         * @param {Group} [group] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(group?: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.updateGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * Crea un grupo de dos usuarios. Cada usuario solo puede pertenecer a un grupo
         * @summary Crear el grupo
         * @param {CreateGroupRequest} [createGroupRequest] Cuerpo de peticion para crear nuevo grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupRequest?: CreateGroupRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.createGroup(createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Borra el grupo mediante el token de sesion JWT del usuario
         * @summary Borrar el grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.deleteGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * Se obtiene informacion del grupo mediante el token de sesion del JWT del usuario
         * @summary Obtener los datos del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * Se manda un correo electronico con la invitacion para unirse al grupo
         * @summary Invitar a la pareja al grupo
         * @param {string} email Correo electronico del usuario a invitar al grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteToGroup(email: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.inviteToGroup(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifica los datos del grupo, los campos a modificar se elegen de manera opcional
         * @summary Modificar los datos del grupo
         * @param {Group} [group] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group?: Group, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateGroup(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * Crea un grupo de dos usuarios. Cada usuario solo puede pertenecer a un grupo
     * @summary Crear el grupo
     * @param {CreateGroupRequest} [createGroupRequest] Cuerpo de peticion para crear nuevo grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(createGroupRequest?: CreateGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).createGroup(createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Borra el grupo mediante el token de sesion JWT del usuario
     * @summary Borrar el grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Se obtiene informacion del grupo mediante el token de sesion del JWT del usuario
     * @summary Obtener los datos del grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Se manda un correo electronico con la invitacion para unirse al grupo
     * @summary Invitar a la pareja al grupo
     * @param {string} email Correo electronico del usuario a invitar al grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public inviteToGroup(email: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).inviteToGroup(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifica los datos del grupo, los campos a modificar se elegen de manera opcional
     * @summary Modificar los datos del grupo
     * @param {Group} [group] Cuerpo de peticion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(group?: Group, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewardApi - axios parameter creator
 * @export
 */
export const RewardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Crear una recompensa dentro del grupo
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward: async (reward?: Reward, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reward`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reward, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Borra una recompensa del brupo mediante su ID
         * @summary Borrar una recompensa del grupo
         * @param {number} id ID de la recompensa a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewardById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRewardById', 'id', id)
            const localVarPath = `/reward/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene el listado de todas las recompensas del grupo
         * @summary Obtener el listado de las recompensas del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRewardList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group/reward`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se obtiene informacion de una recompensa del grupo mediante su ID
         * @summary Obtener los datos de una recompensa del grupo
         * @param {number} id ID de la recompensa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRewardById', 'id', id)
            const localVarPath = `/reward/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Canjear una recompensa, que ha creado, del grupo, en el que se encuentra el usuario, con los puntos ganatos por la completacion de tareas. Puede tener valor negativo y para completar el canjeo se debe validar por la pareja, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Canjear una recompensa del grupo
         * @param {number} id ID de la recompensa a canjear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReward: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('redeemReward', 'id', id)
            const localVarPath = `/reward/redeem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifica una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Modifica una recompensa dentro del grupo
         * @param {number} id ID de la recompensa
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReward: async (id: number, reward?: Reward, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateReward', 'id', id)
            const localVarPath = `/reward/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reward, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validar el canjeo de una recompensa, se debe hacer por el usuario distinto al creador, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Validar el canjeo de una recompensa
         * @param {number} id Numeric ID of the reward to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateReward: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('validateReward', 'id', id)
            const localVarPath = `/reward/validate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardApi - functional programming interface
 * @export
 */
export const RewardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Crear una recompensa dentro del grupo
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReward(reward?: Reward, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReward(reward, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.createReward']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Borra una recompensa del brupo mediante su ID
         * @summary Borrar una recompensa del grupo
         * @param {number} id ID de la recompensa a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewardById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewardById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.deleteRewardById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Obtiene el listado de todas las recompensas del grupo
         * @summary Obtener el listado de las recompensas del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRewardList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reward>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRewardList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.getGroupRewardList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Se obtiene informacion de una recompensa del grupo mediante su ID
         * @summary Obtener los datos de una recompensa del grupo
         * @param {number} id ID de la recompensa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.getRewardById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Canjear una recompensa, que ha creado, del grupo, en el que se encuentra el usuario, con los puntos ganatos por la completacion de tareas. Puede tener valor negativo y para completar el canjeo se debe validar por la pareja, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Canjear una recompensa del grupo
         * @param {number} id ID de la recompensa a canjear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemReward(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemReward(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.redeemReward']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modifica una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Modifica una recompensa dentro del grupo
         * @param {number} id ID de la recompensa
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReward(id: number, reward?: Reward, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReward(id, reward, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.updateReward']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Validar el canjeo de una recompensa, se debe hacer por el usuario distinto al creador, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Validar el canjeo de una recompensa
         * @param {number} id Numeric ID of the reward to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateReward(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateReward(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RewardApi.validateReward']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RewardApi - factory interface
 * @export
 */
export const RewardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardApiFp(configuration)
    return {
        /**
         * Crea una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Crear una recompensa dentro del grupo
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward(reward?: Reward, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.createReward(reward, options).then((request) => request(axios, basePath));
        },
        /**
         * Borra una recompensa del brupo mediante su ID
         * @summary Borrar una recompensa del grupo
         * @param {number} id ID de la recompensa a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewardById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.deleteRewardById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene el listado de todas las recompensas del grupo
         * @summary Obtener el listado de las recompensas del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRewardList(options?: any): AxiosPromise<Array<Reward>> {
            return localVarFp.getGroupRewardList(options).then((request) => request(axios, basePath));
        },
        /**
         * Se obtiene informacion de una recompensa del grupo mediante su ID
         * @summary Obtener los datos de una recompensa del grupo
         * @param {number} id ID de la recompensa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardById(id: number, options?: any): AxiosPromise<Reward> {
            return localVarFp.getRewardById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Canjear una recompensa, que ha creado, del grupo, en el que se encuentra el usuario, con los puntos ganatos por la completacion de tareas. Puede tener valor negativo y para completar el canjeo se debe validar por la pareja, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Canjear una recompensa del grupo
         * @param {number} id ID de la recompensa a canjear
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReward(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.redeemReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifica una recompensa dentro del grupo en el que se encuentra el usuario
         * @summary Modifica una recompensa dentro del grupo
         * @param {number} id ID de la recompensa
         * @param {Reward} [reward] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReward(id: number, reward?: Reward, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateReward(id, reward, options).then((request) => request(axios, basePath));
        },
        /**
         * Validar el canjeo de una recompensa, se debe hacer por el usuario distinto al creador, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Validar el canjeo de una recompensa
         * @param {number} id Numeric ID of the reward to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateReward(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.validateReward(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardApi - object-oriented interface
 * @export
 * @class RewardApi
 * @extends {BaseAPI}
 */
export class RewardApi extends BaseAPI {
    /**
     * Crea una recompensa dentro del grupo en el que se encuentra el usuario
     * @summary Crear una recompensa dentro del grupo
     * @param {Reward} [reward] Cuerpo de peticion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public createReward(reward?: Reward, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).createReward(reward, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Borra una recompensa del brupo mediante su ID
     * @summary Borrar una recompensa del grupo
     * @param {number} id ID de la recompensa a borrar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public deleteRewardById(id: number, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).deleteRewardById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene el listado de todas las recompensas del grupo
     * @summary Obtener el listado de las recompensas del grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public getGroupRewardList(options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).getGroupRewardList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Se obtiene informacion de una recompensa del grupo mediante su ID
     * @summary Obtener los datos de una recompensa del grupo
     * @param {number} id ID de la recompensa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public getRewardById(id: number, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).getRewardById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Canjear una recompensa, que ha creado, del grupo, en el que se encuentra el usuario, con los puntos ganatos por la completacion de tareas. Puede tener valor negativo y para completar el canjeo se debe validar por la pareja, al menos que no se diga lo contrario en los ajustes del grupo
     * @summary Canjear una recompensa del grupo
     * @param {number} id ID de la recompensa a canjear
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public redeemReward(id: number, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).redeemReward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifica una recompensa dentro del grupo en el que se encuentra el usuario
     * @summary Modifica una recompensa dentro del grupo
     * @param {number} id ID de la recompensa
     * @param {Reward} [reward] Cuerpo de peticion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public updateReward(id: number, reward?: Reward, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).updateReward(id, reward, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validar el canjeo de una recompensa, se debe hacer por el usuario distinto al creador, al menos que no se diga lo contrario en los ajustes del grupo
     * @summary Validar el canjeo de una recompensa
     * @param {number} id Numeric ID of the reward to validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardApi
     */
    public validateReward(id: number, options?: RawAxiosRequestConfig) {
        return RewardApiFp(this.configuration).validateReward(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aprueba la creacion de una tarea del grupo, se debe hacer por la pareja del usuario creador de la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Aprueba la creacion de una tarea del grupo
         * @param {number} id ID de la tarea a aprobar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveTaskById', 'id', id)
            const localVarPath = `/task/approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completa una tarea (aprobada) del grupo. Para recibir los puntos, el usuario debe esperar la validacion, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Completar una tarea del grupo
         * @param {number} id ID de la tarea a completar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeTaskById', 'id', id)
            const localVarPath = `/task/complete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crear una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Crear una tarea dentro del grupo
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (task?: Task, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Borra una tarea del grupo mediante su ID
         * @summary Borrar una tarea del grupo
         * @param {number} id ID de la tarea a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaskById', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene el listado de todas las tareas del grupo
         * @summary Obtener el listado de tares del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTaskList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se obtiene informacion de una tarea del grupo mediante su ID
         * @summary Obtener los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskById', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidar la completacion de una tarea del grupo, debe ser permitida en los ajustes del grupo. Lo pueden hacer todos los mienmbos del grupo
         * @summary Invalidar la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada y validada a invalidar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inValidateTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inValidateTaskById', 'id', id)
            const localVarPath = `/task/invalidate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modificar los datos de una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Modificar los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, task?: Task, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Valida la completacion de una tarea (completada) del grupo, para que el usuario pueda recibir sus puntos. La validacion se hace por el usuario distinto al quien haya completado la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Valida la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada a validar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTaskById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('validateTaskById', 'id', id)
            const localVarPath = `/task/validate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * Aprueba la creacion de una tarea del grupo, se debe hacer por la pareja del usuario creador de la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Aprueba la creacion de una tarea del grupo
         * @param {number} id ID de la tarea a aprobar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.approveTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Completa una tarea (aprobada) del grupo. Para recibir los puntos, el usuario debe esperar la validacion, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Completar una tarea del grupo
         * @param {number} id ID de la tarea a completar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.completeTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Crear una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Crear una tarea dentro del grupo
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(task?: Task, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(task, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.createTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Borra una tarea del grupo mediante su ID
         * @summary Borrar una tarea del grupo
         * @param {number} id ID de la tarea a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.deleteTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Obtiene el listado de todas las tareas del grupo
         * @summary Obtener el listado de tares del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupTaskList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupTaskList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getGroupTaskList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Se obtiene informacion de una tarea del grupo mediante su ID
         * @summary Obtener los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Invalidar la completacion de una tarea del grupo, debe ser permitida en los ajustes del grupo. Lo pueden hacer todos los mienmbos del grupo
         * @summary Invalidar la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada y validada a invalidar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inValidateTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inValidateTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.inValidateTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modificar los datos de una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Modificar los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, task?: Task, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, task, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.updateTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Valida la completacion de una tarea (completada) del grupo, para que el usuario pueda recibir sus puntos. La validacion se hace por el usuario distinto al quien haya completado la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Valida la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada a validar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTaskById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTaskById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.validateTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * Aprueba la creacion de una tarea del grupo, se debe hacer por la pareja del usuario creador de la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Aprueba la creacion de una tarea del grupo
         * @param {number} id ID de la tarea a aprobar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTaskById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.approveTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completa una tarea (aprobada) del grupo. Para recibir los puntos, el usuario debe esperar la validacion, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Completar una tarea del grupo
         * @param {number} id ID de la tarea a completar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTaskById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.completeTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Crear una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Crear una tarea dentro del grupo
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(task?: Task, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.createTask(task, options).then((request) => request(axios, basePath));
        },
        /**
         * Borra una tarea del grupo mediante su ID
         * @summary Borrar una tarea del grupo
         * @param {number} id ID de la tarea a borrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.deleteTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene el listado de todas las tareas del grupo
         * @summary Obtener el listado de tares del grupo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTaskList(options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.getGroupTaskList(options).then((request) => request(axios, basePath));
        },
        /**
         * Se obtiene informacion de una tarea del grupo mediante su ID
         * @summary Obtener los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById(id: number, options?: any): AxiosPromise<Task> {
            return localVarFp.getTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidar la completacion de una tarea del grupo, debe ser permitida en los ajustes del grupo. Lo pueden hacer todos los mienmbos del grupo
         * @summary Invalidar la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada y validada a invalidar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inValidateTaskById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.inValidateTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Modificar los datos de una tarea dentro del grupo en el que se encuentra el usuario
         * @summary Modificar los datos de una tarea del grupo
         * @param {number} id ID de la tarea a obtener
         * @param {Task} [task] Cuerpo de peticion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, task?: Task, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateTask(id, task, options).then((request) => request(axios, basePath));
        },
        /**
         * Valida la completacion de una tarea (completada) del grupo, para que el usuario pueda recibir sus puntos. La validacion se hace por el usuario distinto al quien haya completado la tarea, al menos que no se diga lo contrario en los ajustes del grupo
         * @summary Valida la completacion de una tarea del grupo
         * @param {number} id ID de la tarea completada a validar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTaskById(id: number, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.validateTaskById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Aprueba la creacion de una tarea del grupo, se debe hacer por la pareja del usuario creador de la tarea, al menos que no se diga lo contrario en los ajustes del grupo
     * @summary Aprueba la creacion de una tarea del grupo
     * @param {number} id ID de la tarea a aprobar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public approveTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).approveTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completa una tarea (aprobada) del grupo. Para recibir los puntos, el usuario debe esperar la validacion, al menos que no se diga lo contrario en los ajustes del grupo
     * @summary Completar una tarea del grupo
     * @param {number} id ID de la tarea a completar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public completeTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).completeTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crear una tarea dentro del grupo en el que se encuentra el usuario
     * @summary Crear una tarea dentro del grupo
     * @param {Task} [task] Cuerpo de peticion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(task?: Task, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).createTask(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Borra una tarea del grupo mediante su ID
     * @summary Borrar una tarea del grupo
     * @param {number} id ID de la tarea a borrar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).deleteTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene el listado de todas las tareas del grupo
     * @summary Obtener el listado de tares del grupo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getGroupTaskList(options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getGroupTaskList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Se obtiene informacion de una tarea del grupo mediante su ID
     * @summary Obtener los datos de una tarea del grupo
     * @param {number} id ID de la tarea a obtener
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidar la completacion de una tarea del grupo, debe ser permitida en los ajustes del grupo. Lo pueden hacer todos los mienmbos del grupo
     * @summary Invalidar la completacion de una tarea del grupo
     * @param {number} id ID de la tarea completada y validada a invalidar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public inValidateTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).inValidateTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modificar los datos de una tarea dentro del grupo en el que se encuentra el usuario
     * @summary Modificar los datos de una tarea del grupo
     * @param {number} id ID de la tarea a obtener
     * @param {Task} [task] Cuerpo de peticion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: number, task?: Task, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).updateTask(id, task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Valida la completacion de una tarea (completada) del grupo, para que el usuario pueda recibir sus puntos. La validacion se hace por el usuario distinto al quien haya completado la tarea, al menos que no se diga lo contrario en los ajustes del grupo
     * @summary Valida la completacion de una tarea del grupo
     * @param {number} id ID de la tarea completada a validar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public validateTaskById(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).validateTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



